## （转）一位读者小姐姐的阿里Java后台面经分享

面试题由Guide哥的[文章](https://juejin.im/post/6854818586964262926?utm_source=gold_browser_extension#heading-1)中，提取面试题，搜索答案而成。

## 项目相关

### 介绍一下你简历上写的项目？自己主要做了什么？

### 你觉得项目里给你最大的挑战是什么？遇到了什么问题？如何解决的？从中学到了什么？

### 项目的架构图能画一下不？

### 觉得项目有哪些地方可以改进完善？

### 为什么要用Nginx?有啥用？优缺点？

1. Nginx主要用来做请求的反向代理Web服务器和负载均衡。

优点：

1. Nginx由C编写，相比Apache，占用的资源和内存低性能高。
2. 能抗高并发，Nginx处理请求是异步非阻塞的，而Apache是阻塞型的，在高并发下Nginx能保持低资源低消耗高性能，而Apache在后端处理慢和前端压力很大时，很容易出现进程数飙升，从而拒绝服务的现象。 
3. Nginx处理静态文件好，静态处理性能比Apache高三倍以上。
4. Nginx的设计高度模块化，编写模块相对简单。
5. Nginx配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，Apache配置复杂，重启的时候发现配置出错了，会崩溃。
6. Nginx作为负载均衡服务器，支持7层负载均衡。
7. Nginx本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器。
8. 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级。

缺点：

1. Nginx是单进程多线程，进程死掉会影响很多用户。Apache是一个连接对应一个进程，比较占资源，请求数量过多时极容易出现服务器卡死现象，好处是比较稳定，一个进程死掉只会影响一个人。

### 有没有遇到过内存泄漏的场景?

## Java基础

### StringBuilder和StringBuffer的区别

- StringBuffer是线程安全的，StringBuilder是线程不安全的。

### 如何实现静态代理？有啥缺陷？

静态代理实现步骤：

1. 被代理类抽取接口，代理类实现接口。
2. 代理类的构造方法注入被代理类，或者提供set方法注入被代理类。
3. 代理类实现接口方法，并对接口方法进行拦截等处理，按业务情况，拦截或调用被代理类进行处理。

静态代理的缺陷：

1. 静态代理需要手写代理类，让有100个被代理类，就需要写100个代理类。
2. 静态代理可以对方法增加事务处理，如果很多方法都要事务处理，很多方法都要写一次处理调用，会有很多重复代码。
3. 动态代理，可以对方法名进行判断，进行统一处理，而不需要每个方法都调用一次。

### 动态代理的作用？在哪些地方用到了？

什么是动态代理：

1. 动态生成代理类，给被代理类进行增强，例如事务、权限、性能监控、日志等。相比静态代理，代理类是动态生成的，更加解耦、更灵活。
2. 动态代理有JDK的动态代理和CGLIB动态代理。JDK的动态代理要求被代理类有接口，而CGLIB而不需要，Cglib的实现方式是生成子类，继承被代理类。

应用场景：

1. AOP、RPC、OpenFeign，以及Http请求框架Retrofit，等都用了动态代理。

### JDK的动态代理和CGLIB有什么区别？

1. JDK的动态代理，只能实现了接口的类生成代理，没有接口则用不了。
2. CGLIB针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，所以被代理类不能是final修饰的类，方法也不能是final修饰。
3. CGLIB底层采用ASM字节码生成框架，使用字节码技术生成代理类。
4. Spring的动态代理是JDK动态代理和CGLIB都有用，当Bean实现类有接口时，Spring会使用JDK动态代理，当没有实现接口时，就会使用CGLIB来实现。
5. JDK在1.8中效率比CGLIB高，之前则是CGLIB高一些。证明JDK在不断优化。

### 谈谈对Java注解的理解，解决了什么问题？

注解也叫元数据，是JDK1.5引入的特性，可以声明在类、字段、方法、变量、方法参数等地方。

作用分类：

1. 编写文档，可以根据注解生成JavaDOC，或者通过Swagger生成接口文档以及测试网页。
2. 注解一般会配合反射、动态代理使用，使用注解按约定标识，应用启动时，扫描注解，进行增强等，例如依赖注入、参数验证等，接口+注解+动态代理可以实现只写接口不写实现，例如MyBatis和Retrofit，以及微服务间服务调用的Feign，屏蔽了服务间的接口调用，负载均衡，更加简洁。
3. 注解除了能配合反射查找外，还可以配合ASM对字节码进行编译期插桩，例如安卓中的大数据库采集。
4. 注解还可以喝AOP配合，例如Spring的AOP，SpringAOP使用了AspectJ来实现。

### Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？

什么是反射？

- Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

反射的优缺点：

- 优点： 运行期类型的判断，动态加载类，提高代码灵活度。
- 缺点：
    1. 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
    2. 安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。
    
为什么框架需要反射？

动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

1. 我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序。
2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系。
3. MyBatis的Mapper接口，使用了动态代理生成实现类，以及反射查找注解。
4. SpringMVC的Controller，注解声明每个接口方法的请求地址，请求参数，请求方式，验证规则等。

## 集合框架

### HashMap的底层实现、JDK1.8的时候为啥将链表转换成红黑树？

HashMap的底层实现，在1.7之前，是由数组 + 链表实现的，存储数据时，会对数据进行Hash取模，得到的值放到响应Hash的数组位置。
再放入下一个值时，当算出同一个Hash值时，就会发生Hash碰撞，会再上一个值的节点位置生成一个链表，再将值放进去。当链表长度达到8时，就会将链表转换为红黑树。

为什么要转换，链表的查找效率是O(n)，就是效率最低的遍历，一个个找。而红黑树的时间复杂度是O(1)。

### HashMap的负载因子

HashMap的负载因子是0.75，负载因子是和扩容机制有关的，意思是如果当前容器的容量，达到了我们设定的最大值，就要开始执行扩容操作。
> 比如说当前的容器容量是16，负载因子是0.75,16*0.75=12，也就是说，当容量达到了12的时候就会进行扩容操作。

为什么是0.75？首先要想到的是HashMap只是一个数据结构，既然是数据结构最主要的就是节省时间和空间。负载因子的作用肯定也是节省时间和空间。

- 如果是1.0，例如HashMap的容量是8，元素个数达到8，全部填满时，才进行扩容，Hash碰撞是避免不了的，因为空间满了，就会有大量的Hash冲突，查询效率会很低，这种情况就是牺牲了时间来换空间。
- 如果是0.5，这就是意味着元素个数达到容量的一半时，就开始扩容。既然填充的个数少了，Hash冲突也少，查询效率会提高，但是这样空间利用率会大大降低，原本存储1M大小的数据，现在需要2M空间来存。空间利用率低。
- 一句话来讲，负载因子太小，虽然时间效率高了，但是空间利用效率会低。

而0.75是测试出来的，在0.75时，空间利用率较高，避免了相当多的Hash冲突，所以该值是空间和时间权衡出来的值。

### HashMap和Hashtable的区别？

1. HashMap、Hashtable都基于哈希表实现的，是线程不安全的，而Hashtable是线程安全的。
2. Hashtable继承自Dictionary，而HashMap继承自AbstractMap。
2. HashMap支持null值，key和value都可以，但只能有一个null键，但value可以多个为null。而Hashtable不支持null键和null值，插入会抛出空指针异常。
3. Hashtable所有方法都加了同步锁，效率较低，如果在多线程下使用，想要线程完全，可以使用ConcurrentHashMap。

### 有哪些集合是线程不安全的？怎么解决呢？

线程安全的集合：
1. Vector
2. HashTable

线程不安全的集合：
1. ArrayList
2. LinkedList
3. HashSet
4. TreeSet
5. HashMap
6. TreeMap

如果想将线程不安全的集合转换为线程安全的，可以使用Collections工具类，将集合实例包装为线程安全的集合，Collections提供了如下几个静态方法给我们使用。

```
//返回指定collection 对应的线程安全的collection。
<T> Collection<T> synchronizedCollection(Collection<T> c);
//返回指定List对象对应的线程安全的List 对象。
static <T> List<T> synchronizedList(List<T> list);
//返回指定Map对象对应的线程安全的Map对象。
static <K, V> Map<K, V> synchronizedMap(Map<K, V> m);
//返回指定Set对象对应的线程安全的Set对象。
static <T> Set<T> synchronizedSet(Set<T> s);
//返回指定SortedMap对象对应的线程安全的SortedMap对象。
static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> m);
```

上面包装后的集合对象，所有方法都加了同步锁，效率很低，现在推荐使用JUC下的集合。有如下对应关系：

1. ArrayList对应的高并发类是CopyOnWriteArrayList
2. HashSet对应的高并发类是CopyOnWriteArraySet
3. HashMap对应的高并发类是ConcurrentHashMap

- CopyOnWriteArrayList，写时复制，当执行写操作时，先copy一份原有数据数组，再对复制数据进行写入操作，最后将复制数据替换原有数据，从而保证写操作不影响读操作。
同时，其复制的整个过程是上了锁的，所以不会产生多线程安全问题。

    1. 等待可终止：如果一个线程长期占有锁对象不释放，那么等待的线程可以选择停止等待，这样也避免了死锁的发生
    2. 公平锁：等待的线程必须按照申请的时间顺序去持有锁对象
    3. 并不像synchronized那样要么唤醒一个线程，要么唤醒所有线程，实现了可以分组唤醒需要唤醒的线程

- CopyOnWriteArraySet与CopyOnWriteArrayList类似，只不过前面的数据无序，不可重复。

- ConcurrentHashMap

    1. 和hashMap不同的是，concurrentHashMap的key和value都不允许为null
    2. put()方法，主要应用了锁分段的技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，put方法中首先就是通过算法找到负责这段数据的分段锁。
    
简而言之：

JUC下的集合采用了读取操作时不加锁，而在修改数据时：
1. CopyOnWriteArrayList使用ReentrantLock这种互斥锁的特性(1.等待停止、2.公平锁、3.分组唤醒)避免了线程进入阻塞状态，从而达到高效。
2. ConcurrentHashMap使用锁分段技术保证了数据的安全且高效。

### 什么是快速失败(fail-fast)、能举个例子吗？、什么是安全失败(fail-safe)呢？

java.util包下面的所有集合类都是快速失败的，而Java.util.concurent包下面的集合类都是安全失败。

- 快速失败：迭代器会抛出ConcurrentModificationException异常
- 安全失败：它的迭代器永远不会抛出这样的异常

>  快速失败(fail-fast)

为什么在使用迭代器遍历集合时，修改集合会抛出异常？

- 原因是：迭代器在遍历集合时会直接访问集合中的内容，并且在遍历的过程中使用一个modCount的变量，集合在遍历期间如果发生了变化，就会改变modCount的值。
每当迭代器使用 hashNext()/next() 遍历下一个元素之前都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。

> 安全失败(fail-safe)

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容在拷贝的集合上进行遍历。
由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛ConcurrentModificationException异常。

最后说明一下，快速失败和安全失败是对迭代器而言的。并发环境下建议使用 java.util.concurrent 包下的容器类，除非没有修改操作。

## 多线程

### 在多线程情况下如何保证线程安全

### synchronized 作用，底层实现

### ReetrantLock 和 synchronized 的区别

### AQS

### 线程池作用？Java 线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？

### 线程死锁

### ThreadLocal 是什么，应用场景是什么，原理是怎样的

### 介绍一下 Java 有哪些锁(synchronized、juc 提供的锁如 ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore 等)

## JVM

### 讲一下 JVM 的内存结构（还问了每个区域的调优配置参数，我蒙了)

### Minor gc 和 Full gc 的区别，详细介绍

### 方法区和永久代的关系？

### JDK 1.8 HotSpot 的永久代为啥被彻底移除？有哪些常用参数？

### 主要进行 gc 的区域。永久代会发生 gc 吗？元空间呢？

### 各种垃圾回收算法和回收器，说出自己的理解

### zgc ？zgc vs g1？（我懵逼了~我只是听过有这个东西，完全没有去了解过）

## 数据库

### 讲一下乐观锁和悲观锁

### 说一下 MVCC

### 说一聚簇索引和非聚簇索引的有什么不同

### 关于索引的各种轰炸**(索引相关的知识太重要了！！！**)

## 网络

### 为什么网络要分层？

### TCP/IP 4 层模型了解么？

### http 是哪一层的协议？

### http 和 https 什么区别

### http2.0（不知道）

### tcp 三次握手过程、滑动窗口是干什么的？

### Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？

### 当你打开一个电商网站，都需要经历哪些过程？

### 电子邮件的发送过程?

## Spring

### Spring AOP 和 IOC 的底层实现

### Spring Boot 了解不？和 Spring 啥区别？

### Spring Boot 的启动类源码有了解过吗

## 其他

### 工作想 base 在哪里？为什么？

### 平时有什么兴趣爱好？

### 自己未来有什么规划？

### 平时是如何学习新技术的？（官网/书籍/博客/视频）

### 一般遇到问题如何解决？（Google 和 Stackoverflow，虽然我平时很少用 Stackoverflow，但是还是和面试官说我经常用，哈哈哈！）

### 介不介意加班？（求生欲让我回答不介意）

### 你有什么问题想问我？（我问了工作强度）