# 数据库事务

## 数据库事务的四大特性（ACID）

1. Atomic 原子性
    - 定义：原子性是指事务是一个不可分割的工作单位。事务中的操作要么都发生，要么都不发生。
    - 实际案例：转账，A加钱，B减钱，要么同时成功，要么同时失败

2. Consistency 一致性
    - 定义：一致性指的是事务前后数据的完整性必须保持一致
    - 实际案例：加钱和减钱，操作前、后钱的总和要一致

3. Isolation 隔离性
    - 定义：隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发事务之间的数据要相互隔离
    - 实际案例：好几个同时人给A转钱，或者好几个人同时给B转钱，多个事务并发执行，并不会影响一致性

4. Durability 持久性
    - 定义：持久性指的是一个事务一旦被提交了，它对数据库中数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响
    - 实际案例：转钱了，数据库突然宕机了，恢复之后，这笔交易还存在
    
## 数据库安全性问题

如果不考虑隔离性，会引发以下3种安全性问题：

- 脏读：一个事务读取了另外一个数据改写但还未提交的数据，如果这些数据回滚，则读到的数据时无效的
    > 公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。
    >> 出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。
- 不可重复度：在同一个事务中，读取到了另一个数据已经更新的数据，而导致整个事务中，多次读取到的查询结果不一致
    > singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何…
    >> 出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
- 幻读：一个事务读，取到了另外一个事务已经提交的插入的记录，而导致在后来的查询中，多次读取到的查询结果不一致
    > singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉。

- 脏读

**而隔离级别就是用来解决以上3种安全性问题！**

## 数据库隔离级别

注意：我们讨论隔离级别的场景，主要是在多个事务并发的情况下，因此，接下来的讲解都围绕事务并发。

1. READ_UNCOMMITED：允许你读取还未提交的改变了的数据，可导致脏读、幻读、不可重复度
2. READ_COMMITTED：允许在并发事务已经提交后读取。可防止脏读，但幻读和不可重复读任可发生（Oracle、Sql Server默认使用该隔离级别）
3. REPEATABLE_READ：对相同字段的多次读取是一致性的，除非数据被事务本身改变，可防止脏读、不可重复读，但幻读仍可发生（MySQL默认使用该隔离级别）
4. SERIALIZABLE：完全服从ACID的隔离级别，确保不发生脏读、幻读、不可重复度，这在所有的隔离级别中性能是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的

## 事务的传播行为

主要是为了处理业务层复杂调用时，事务的传播处理。事务的传播行为分为7种，常用为前2种：

- PROPAGATION_REQUIRED：支持当前事务。如果不存在就新建-个
- PROPAGATION_SUPPORTS：支持当前事务，如果不存在,就不使用事务
- PROPAGATION_MANDATORY：支持当前事务,如果不存在,抛出异常
- PROPAGATION_REQUIRES NEW：如果有事务存在，挂起当前事务。创建一个新的事务
- PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务
- PROPAGATION_NEVER：以非事务方式运行，如果有事务存在，抛出异常
- PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行

一般使用前2种，就是PROPAGATION_REQUIRED、PROPAGATION_SUPPORTS。
1. 增删改：就是PROPAGATION_REQUIRED，有事务则加入，没有在则创建
2. 查：PROPAGATION_SUPPORTS，没有事务，那就不使用事务